====
Home
====

Welcome to Nim
--------------

**Nim** (formerly known as "Nimrod") is a statically typed, imperative
programming language that tries to give the programmer ultimate power without
compromises on runtime efficiency. This means it focuses on compile-time
mechanisms in all their various forms.

Beneath a nice infix/indentation based syntax with a
powerful (AST based, hygienic) macro system lies a semantic model that supports
a soft realtime GC on thread local heaps. Asynchronous message passing is used
between threads, so no "stop the world" mechanism is necessary. An unsafe
shared memory heap is also provided for the increased efficiency that results
from that model.


Nim is efficient
================

* Native code generation (currently via compilation to C), not dependent on a
  virtual machine: **Nim produces small executables without dependencies
  for easy redistribution.**
* A fast **non-tracing** garbage collector that supports soft
  real-time systems (like games).
* System programming features: Ability to manage your own memory and access the
  hardware directly. Pointers to garbage collected memory are distinguished
  from pointers to manually managed memory.
* Zero-overhead iterators.
* Cross-module inlining.
* Dynamic method binding with inlining and without virtual method table.
* Compile time evaluation of user-defined functions.
* Whole program dead code elimination: Only *used functions* are included in
  the executable.
* Value-based datatypes: For instance, objects and arrays can be allocated on
  the stack.


Nim is expressive
=================

* **The Nim compiler and all of the standard libraries are implemented in
  Nim.**
* Built-in high level datatypes: strings, sets, sequences, etc.
* Modern type system with local type inference, tuples, variants,
  generics, etc.
* User-defineable operators; code with new operators is often easier to read
  than code which overloads built-in operators. For example, a
  ``=~`` operator is defined in the ``re`` module.
* Macros can modify the abstract syntax tree at compile time.


Nim is elegant
==============

* Macros can use the imperative paradigm to construct parse trees. Nim
  does not require a different coding style for meta programming.
* Macros cannot change Nim's syntax because there is no need for it.
  Nim's syntax is flexible enough.
* Statements are grouped by indentation but can span multiple lines.
  Indentation must not contain tabulators so the compiler always sees
  the code the same way as you do.


Nim plays nice with others
==========================

* The Nim Compiler runs on Windows, Linux, BSD and Mac OS X.
  Porting to other platforms is easy.
* **The Nim Compiler can also generate C++ or Objective C for easier
  interfacing.**
* There are lots of bindings: for example, bindings to GTK2, the Windows API,
  the POSIX API, OpenGL, SDL, Cairo, Python, Lua, TCL, X11, libzip, PCRE,
  libcurl, mySQL and SQLite are included in the standard distribution or
  can easily be obtained via the
  `Nimble package manager <https://github.com/nim-lang/nimble>`_.
* A C to Nim conversion utility: New bindings to C libraries are easily
  generated by ``c2nim``.


Roadmap to 1.0
==============

Please have a look at
this `wiki page <https://github.com/nim-lang/Nim/wiki/Roadmap>`_ for
an up-to-date overview.
